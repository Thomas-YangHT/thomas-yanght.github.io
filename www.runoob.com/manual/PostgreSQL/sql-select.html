<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>SELECT</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="SECURITY LABEL" HREF="sql-security-label.html"><LINK REL="NEXT" TITLE="SELECT INTO" HREF="sql-selectinto.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/select.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="SECURITY LABEL" HREF="sql-security-label.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="SELECT INTO" HREF="sql-selectinto.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-SELECT"></A>SELECT</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN79638"></A><H2>&#21517;&#31216;</H2>SELECT, TABLE, WITH&nbsp;--&nbsp;从表或视图中取出若干行</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN79650"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">[ WITH [ RECURSIVE ] <TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ) ] ]
    * | <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>output_name</I
></TT
> ] [, ...]
    [ FROM <TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> [, ...] ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> ]
    [ GROUP BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ]
    [ HAVING <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> [, ...] ]
    [ WINDOW <TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
> AS ( <TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
> ]
    [ ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> | ALL } ]
    [ OFFSET <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [, ...] ] [ NOWAIT ] [...] ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>这里的<TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> 可以是:</SPAN
></SPAN
>

    [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ * ] [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ] ]
    [ LATERAL ] ( <TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
> ) [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ]
    <TT
CLASS="REPLACEABLE"
><I
>with_query_name</I
></TT
> [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ] ]
    [ LATERAL ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ] ) [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] | <TT
CLASS="REPLACEABLE"
><I
>column_definition</I
></TT
> [, ...] ) ]
    [ LATERAL ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ] ) AS ( <TT
CLASS="REPLACEABLE"
><I
>column_definition</I
></TT
> [, ...] )
    <TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> [ NATURAL ] <TT
CLASS="REPLACEABLE"
><I
>join_type</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> [ ON <TT
CLASS="REPLACEABLE"
><I
>join_condition</I
></TT
> | USING ( <TT
CLASS="REPLACEABLE"
><I
>join_column</I
></TT
> [, ...] ) ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
><TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
>是:</SPAN
></SPAN
>

    <TT
CLASS="REPLACEABLE"
><I
>with_query_name</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) ] AS ( <TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>values</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>insert</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>update</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>delete</I
></TT
> )

TABLE [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ * ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN79703"></A><H2>描述</H2><P><TT CLASS="COMMAND">SELECT</TT>将从零个或更多表中返回记录行。<TT CLASS="COMMAND">SELECT</TT>通常的处理如下：
<P></P></P><OL TYPE="1"><LI><P>计算列出在<TT CLASS="LITERAL">WITH</TT>中的所有查询。这些有效的充当可以在
<TT CLASS="LITERAL">FROM</TT>列表中引用的临时表。一个在<TT CLASS="LITERAL">FROM</TT>
中多次引用的<TT CLASS="LITERAL">WITH</TT>查询只计算一次。（参阅下面的
<A HREF="sql-select.html#SQL-WITH"><I><I>WITH</I> 子句</I></A>。）</P></LI><LI><P>计算列出在<TT CLASS="LITERAL">FROM</TT>中的所有元素(<TT CLASS="LITERAL">FROM</TT>
列表中的每个元素都是一个实际的或虚拟的表)。如果在<TT CLASS="LITERAL">FROM</TT>
列表里声明了多个元素，那么他们就交叉连接在一起(参见下面的
<A HREF="sql-select.html#SQL-FROM"><I><I>FROM</I> 子句</I></A>)。</P></LI><LI><P>如果声明了<TT CLASS="LITERAL">WHERE</TT>子句，那么在输出中消除所有不满足条件的行。
（参见下面的<A HREF="sql-select.html#SQL-WHERE"><I><I>WHERE</I> 子句</I></A>。）</P></LI><LI><P>如果声明了<TT CLASS="LITERAL">GROUP BY</TT>子句，输出就组合成匹配一个或多个数值的不同组里。
如果出现了<TT CLASS="LITERAL">HAVING</TT>子句，那么它消除那些不满足给出条件的组。
（参见下面的<A HREF="sql-select.html#SQL-GROUPBY"><I><I>GROUP BY</I> 子句</I></A> 和
<A HREF="sql-select.html#SQL-HAVING"><I><I>HAVING</I> 子句</I></A>。）</P></LI><LI><P>实际输出行将使用<TT CLASS="COMMAND">SELECT</TT>输出表达式针对每一个选中的行或行组进行计算。
（参见下面的<A HREF="sql-select.html#SQL-SELECT-LIST"><I><I>SELECT</I> 列表</I></A>。）</P></LI><LI><P><TT CLASS="LITERAL">SELECT DISTINCT</TT>从结果中消除重复的行。<TT CLASS="LITERAL">SELECT DISTINCT ON</TT>
消除匹配所有指定表达式的行。<TT CLASS="LITERAL">SELECT ALL</TT>（缺省）返回所有的行，
包括重复的行。（参阅下面的<A HREF="sql-select.html#SQL-DISTINCT"><I><I>DISTINCT</I> 子句</I></A>。）</P></LI><LI><P>使用<TT CLASS="LITERAL">UNION</TT>, <TT CLASS="LITERAL">INTERSECT</TT>, <TT CLASS="LITERAL">EXCEPT</TT>
可以把多个<TT CLASS="COMMAND">SELECT</TT>语句的输出合并成一个结果集。<TT CLASS="LITERAL">UNION</TT>
操作符返回两个结果集的并集。<TT CLASS="LITERAL">INTERSECT</TT>操作符返回两个结果集的交集。
<TT CLASS="LITERAL">EXCEPT</TT>操作符返回在第一个结果集对第二个结果集的差集。不管哪种情况，
重复的行都被删除，除非声明了<TT CLASS="LITERAL">ALL</TT>。噪声字<TT CLASS="LITERAL">DISTINCT</TT>
可以用来明确的声明消除重复的行。请注意，<TT CLASS="LITERAL">DISTINCT</TT>在这里是缺省的行为，
即使<TT CLASS="LITERAL">ALL</TT>是<TT CLASS="COMMAND">SELECT</TT>本身的缺省。
（参阅下面的<A HREF="sql-select.html#SQL-UNION"><I><I>UNION</I> 子句</I></A>、<A HREF="sql-select.html#SQL-INTERSECT"><I><I>INTERSECT</I> 子句</I></A>、
<A HREF="sql-select.html#SQL-EXCEPT"><I><I>EXCEPT</I> 子句</I></A>。）</P></LI><LI><P>如果声明了<TT CLASS="LITERAL">ORDER BY</TT>子句，那么返回的行将按照指定的顺序排序。
如果没有给出<TT CLASS="LITERAL">ORDER BY</TT>，那么数据行是按照系统认为可以最快生成的顺序给出的。
（参阅下面的<A HREF="sql-select.html#SQL-ORDERBY"><I><I>ORDER BY</I> 子句</I></A>。）</P></LI><LI><P>如果给出了<TT CLASS="LITERAL">LIMIT</TT>(或 <TT CLASS="LITERAL">FETCH FIRST</TT>)或
<TT CLASS="LITERAL">OFFSET</TT>子句，那么<TT CLASS="COMMAND">SELECT</TT>语句只返回结果行的一个子集。
（参阅下面的<A HREF="sql-select.html#SQL-LIMIT"><I><I>LIMIT</I> 子句</I></A>。）</P></LI><LI><P>如果声明了<TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT>
或<TT CLASS="LITERAL">FOR KEY SHARE</TT>子句，那么<TT CLASS="COMMAND">SELECT</TT>语句对并发的更新锁住选定的行。
（参阅下面的<A HREF="sql-select.html#SQL-FOR-UPDATE-SHARE"><I>锁定子句</I></A>子句。）</P></LI></OL><P>
</P><P>你必须对每个在<TT CLASS="LITERAL">SELECT</TT>命令中使用的字段有<TT CLASS="LITERAL">SELECT</TT>权限。
使用<TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT>
或<TT CLASS="LITERAL">FOR KEY SHARE</TT>还要求<TT CLASS="LITERAL">UPDATE</TT>权限
（至少选择每个表的一列）。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN79787"></A><H2>参数</H2><DIV CLASS="REFSECT2"><A NAME="SQL-WITH"></A><H3><TT CLASS="LITERAL">WITH</TT> 子句</H3><P><TT CLASS="LITERAL">WITH</TT>子句允许声明一个或多个可以在主查询中通过名字引用的子查询。
子查询在主查询期间有效的充当临时表或视图。每个子查询可以是<TT CLASS="COMMAND">SELECT</TT>,
<TT CLASS="COMMAND">VALUES</TT>, <TT CLASS="COMMAND">INSERT</TT>, <TT CLASS="COMMAND">UPDATE</TT> 或
<TT CLASS="COMMAND">DELETE</TT>语句。当在<TT CLASS="LITERAL">WITH</TT>中写一个数据修改语句时
（<TT CLASS="COMMAND">INSERT</TT>, <TT CLASS="COMMAND">UPDATE</TT> 或 <TT CLASS="COMMAND">DELETE</TT>），
通常包含一个<TT CLASS="LITERAL">RETURNING</TT>子句。<TT CLASS="LITERAL">RETURNING</TT>的输出而<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不是</I></SPAN>
语句修改的底层表的输出形成被主查询读取的临时表。如果省略了<TT CLASS="LITERAL">RETURNING</TT>，
该语句仍然执行，但是不会产生输出，所以不能作为一个表被主查询引用。</P><P>必须为每个<TT CLASS="LITERAL">WITH</TT>查询声明一个名字（没有模式修饰）。
可选的，可以指定字段名的列表；如果省略了，那么字段名从子查询中推断出。</P><P>如果声明了<TT CLASS="LITERAL">RECURSIVE</TT>，那么允许<TT CLASS="COMMAND">SELECT</TT>子查询通过名字引用它自己。
比如一个有下面形式的子查询
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>non_recursive_term</I
></TT
> UNION [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>recursive_term</I
></TT
></PRE><P>
递归的自我引用必须在<TT CLASS="LITERAL">UNION</TT>的右边出现。每个查询只允许一个递归的自我引用。
不支持递归的数据修改语句，但是可以在数据修改语句中使用递归的<TT CLASS="COMMAND">SELECT</TT>
查询的结果。参阅<A HREF="queries-with.html">第 7.8 &#33410;</A>获取一个例子。</P><P><TT CLASS="LITERAL">RECURSIVE</TT>的另外一个作用是<TT CLASS="LITERAL">WITH</TT>查询不需要排序：
一个查询可以引用另外一个稍后出现在列表中的查询。（但是，循环引用或相互递归没有实现。）
没有<TT CLASS="LITERAL">RECURSIVE</TT>，<TT CLASS="LITERAL">WITH</TT>查询只能引用
更早出现在<TT CLASS="LITERAL">WITH</TT>列表中的同层级的<TT CLASS="LITERAL">WITH</TT>查询。</P><P><TT CLASS="LITERAL">WITH</TT>查询的主要特性是他们只在主查询的每次执行中评估一次，
即使主查询引用了他们多次也是如此。特别的，保证数据修改语句只被执行一次，
不管主查询读取他们的所有或任意的输出。</P><P>主查询和<TT CLASS="LITERAL">WITH</TT>查询（理论上）同时执行。这意味着<TT CLASS="LITERAL">WITH</TT>
中的数据修改语句的影响不能从查询的其他部分看到，除非读取它的<TT CLASS="LITERAL">RETURNING</TT>
输出。如果两个这样的数据修改语句尝试修改相同的行，那么结果是未知的。</P><P>参阅<A HREF="queries-with.html">第 7.8 &#33410;</A>获取额外的信息。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-FROM"></A><H3><TT CLASS="LITERAL">FROM</TT> 子句</H3><P><TT CLASS="LITERAL">FROM</TT>子句为<TT CLASS="COMMAND">SELECT</TT>声明一个或者多个源表。如果声明了多个源表，
那么结果就是所有源表的笛卡儿积(交叉连接)。但是通常会添加一些条件（通过<TT CLASS="LITERAL">WHERE</TT>），
把返回行限制成笛卡儿积的一个小的子集。</P><P>
<TT CLASS="LITERAL">FROM</TT>子句可以包括下列元素：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>一个现存的表或视图的名字(可以有模式修饰)。如果声明了<TT CLASS="LITERAL">ONLY</TT>，则只扫描该表；
否则，该表和所有其派生表(如果有的话)都被扫描。可以在表名后面跟一个<TT CLASS="LITERAL">*</TT>
表示扫描所有其后代表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>alias</I></TT></DT><DD><P>为那些包含别名的<TT CLASS="LITERAL">FROM</TT>项目取的别名。别名用于缩写或者在自连接中消除歧义
(自连接中同一个表将扫描多次)。如果提供了别名，那么它就会完全隐藏表或者函数的实际名字；
比如，如果给出<TT CLASS="LITERAL">FROM foo AS f</TT>，那么<TT CLASS="COMMAND">SELECT</TT>
剩下的东西必须把这个<TT CLASS="LITERAL">FROM</TT>项按照<TT CLASS="LITERAL">f</TT>而不是<TT CLASS="LITERAL">foo</TT>引用。
如果写了别名，也可以提供一个字段别名列表，这样可以替换表中一个或者多个字段的名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>select</I></TT></DT><DD><P>可以在<TT CLASS="LITERAL">FROM</TT>子句里出现一个子<TT CLASS="COMMAND">SELECT</TT>。
它的输出作用好像是为这条<TT CLASS="COMMAND">SELECT</TT>命令在其生存期里创建一个临时表。
请注意这个子<TT CLASS="COMMAND">SELECT</TT>必须用园括弧包围。并且<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必须</I></SPAN>给它一个别名。
当然，<A HREF="sql-values.html">VALUES</A>同样也可以在这里使用。</P></DD><DT><TT CLASS="REPLACEABLE"><I>with_query_name</I></TT></DT><DD><P><TT CLASS="LITERAL">WITH</TT>查询通过写它自己的名字来引用，就像查询的名字就是一个表的名字。
（实际上，<TT CLASS="LITERAL">WITH</TT>查询为主查询隐藏了相同名字的任意实际表。
如果需要，可以通过模式限定表的名字来引用相同名字的实际表。）别名可以用相同的方式提供给表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>function_name</I></TT></DT><DD><P>函数(特别是那些返回结果集的函数)调用可以出现在<TT CLASS="LITERAL">FROM</TT>子句里。
这么做就好像在这个<TT CLASS="COMMAND">SELECT</TT>命令的生命期中，把函数的输出创建为一个临时表一样。
当然也可以使用别名。如果写了别名，还可以写一个字段别名列表，
为函数返回的复合类型的一个或多个属性提供名字替换。如果函数定义为返回<TT CLASS="TYPE">record</TT>类型，
那么必须出现一个<TT CLASS="LITERAL">AS</TT>关键字或者别名，后面跟着一个形如
<TT CLASS="LITERAL">( <TT CLASS="REPLACEABLE"><I>column_name</I></TT> <TT CLASS="REPLACEABLE"><I>data_type</I></TT> [<SPAN CLASS="OPTIONAL">, ... </SPAN>]
)</TT>的字段定义列表。这个字段定义列表必须匹配函数返回的字段的实际数目和类型。</P></DD><DT><TT CLASS="REPLACEABLE"><I>join_type</I></TT></DT><DD><P>
下列之一：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">[ INNER ] JOIN</TT></P></LI><LI><P><TT CLASS="LITERAL">LEFT [ OUTER ] JOIN</TT></P></LI><LI><P><TT CLASS="LITERAL">RIGHT [ OUTER ] JOIN</TT></P></LI><LI><P><TT CLASS="LITERAL">FULL [ OUTER ] JOIN</TT></P></LI><LI><P><TT CLASS="LITERAL">CROSS JOIN</TT></P></LI></UL><P>
必须为<TT CLASS="LITERAL">INNER</TT>和<TT CLASS="LITERAL">OUTER</TT>连接类型声明一个连接条件，
也就是<TT CLASS="LITERAL">NATURAL</TT>, <TT CLASS="LITERAL">ON <TT CLASS="REPLACEABLE"><I>join_condition</I></TT></TT>, or
<TT CLASS="LITERAL">USING (<TT CLASS="REPLACEABLE"><I>join_column</I></TT> [, ...])</TT> 之一。
它们的含义见下文，对于<TT CLASS="LITERAL">CROSS JOIN</TT>而言，这些子句都不能出现。
</P><P>一个<TT CLASS="LITERAL">JOIN</TT>子句组合两个<TT CLASS="LITERAL">FROM</TT>项，为了方便我们将其作为<SPAN CLASS="QUOTE">"tables"</SPAN>
引用，尽管实际上他们可以是任意<TT CLASS="LITERAL">FROM</TT>条目的类型。必要时使用圆括弧以决定嵌套的顺序。
如果没有圆括弧，<TT CLASS="LITERAL">JOIN</TT>从左向右嵌套。在任何情况下，<TT CLASS="LITERAL">JOIN</TT>
都比逗号分隔的<TT CLASS="LITERAL">FROM</TT>列表绑定得更紧。</P><P><TT CLASS="LITERAL">CROSS JOIN</TT>和<TT CLASS="LITERAL">INNER JOIN</TT>生成一个简单的笛卡儿积，
和你在<TT CLASS="LITERAL">FROM</TT>的顶层列出两个表的结果相同，但是受到连接条件（如果有）的限制。
<TT CLASS="LITERAL">CROSS JOIN</TT>等效于<TT CLASS="LITERAL">INNER JOIN ON (TRUE)</TT>，也就是说，
没有被条件删除的行。这种连接类型只是符号上的方便，因为它们和你用简单的
<TT CLASS="LITERAL">FROM</TT>和<TT CLASS="LITERAL">WHERE</TT>的效果一样。</P><P><TT CLASS="LITERAL">LEFT OUTER JOIN</TT>返回笛卡儿积中所有符合连接条件的行，
再加上左表中通过连接条件没有匹配右表行的那些行。这样，左边的行将扩展成生成表的全长，
方法是在那些右表对应的字段位置填上 NULL 。请注意，只在计算匹配的时候，
才使用<TT CLASS="LITERAL">JOIN</TT>子句的条件，外层的条件是在计算完毕之后施加的。</P><P>相应的，<TT CLASS="LITERAL">RIGHT OUTER JOIN</TT>返回所有内连接的结果行，
加上每个不匹配的右边行(左边用 NULL 扩展)。这只是一个符号上的便利，
因为总是可以把它转换成一个<TT CLASS="LITERAL">LEFT OUTER JOIN</TT>，只要把左边和右边的输入对掉一下即可。</P><P><TT CLASS="LITERAL">FULL OUTER JOIN</TT>返回所有内连接的结果行，加上每个不匹配的左边行(右边用 NULL 扩展)，
再加上每个不匹配的右边行(左边用 NULL 扩展)。</P></DD><DT><TT CLASS="LITERAL">ON <TT CLASS="REPLACEABLE"><I>join_condition</I></TT></TT></DT><DD><P>一个生成<TT CLASS="TYPE">boolean</TT>类型结果的表达式(类似<TT CLASS="LITERAL">WHERE</TT>子句)，
限定连接中那些行是匹配的。</P></DD><DT><TT CLASS="LITERAL">USING ( <TT CLASS="REPLACEABLE"><I>join_column</I></TT> [, ...] )</TT></DT><DD><P>一个形如<TT CLASS="LITERAL">USING ( a, b, ... )</TT> 的子句，是<TT CLASS="LITERAL">ON left_table.a = right_table.a AND
left_table.b = right_table.b ...</TT>的缩写。
同样，<TT CLASS="LITERAL">USING</TT>蕴涵着每对等效字段中只有一个包含在连接输出中，而不是两个都输出的意思。</P></DD><DT><TT CLASS="LITERAL">NATURAL</TT></DT><DD><P><TT CLASS="LITERAL">NATURAL</TT>是一个<TT CLASS="LITERAL">USING</TT>列表的缩写，这个列表说的是两个表中同名的字段。</P></DD><DT><TT CLASS="LITERAL">LATERAL</TT></DT><DD><P><TT CLASS="LITERAL">LATERAL</TT>关键字可以放在一个子<TT CLASS="COMMAND">SELECT</TT> <TT CLASS="LITERAL">FROM</TT>项目的前面。
这允许子<TT CLASS="COMMAND">SELECT</TT>引用出现在<TT CLASS="LITERAL">FROM</TT>列表之前的<TT CLASS="LITERAL">FROM</TT>条目中的字段。
（没有<TT CLASS="LITERAL">LATERAL</TT>，每个子<TT CLASS="COMMAND">SELECT</TT>独立评估并且以此不能交叉引用任何其他
<TT CLASS="LITERAL">FROM</TT>条目。）</P><P><TT CLASS="LITERAL">LATERAL</TT>也可以放在一个函数调用<TT CLASS="LITERAL">FROM</TT>条目的前面，
但是这种情况下它是一个噪声字，因为函数表达式可以在任何情况下引用前面的<TT CLASS="LITERAL">FROM</TT>条目。</P><P><TT CLASS="LITERAL">LATERAL</TT>可以出现在<TT CLASS="LITERAL">FROM</TT>列表的顶层，或出现在<TT CLASS="LITERAL">JOIN</TT>树中。
在后面当前情况下，它也可以引用<TT CLASS="LITERAL">JOIN</TT>左侧和右侧的任意条目。</P><P>当<TT CLASS="LITERAL">FROM</TT>条目包含<TT CLASS="LITERAL">LATERAL</TT>交叉引用时，评估收益如下：
对于提供交叉引用字段的<TT CLASS="LITERAL">FROM</TT>条目的每一行，或提供字段的多个<TT CLASS="LITERAL">FROM</TT>
条目的行集，使用该字段的行或行集值评估<TT CLASS="LITERAL">LATERAL</TT>条目。
结果行像往常一样和计算他们的行连接。这是从字段源表重复每行或行集。</P><P>字段源表必须<TT CLASS="LITERAL">INNER</TT>或<TT CLASS="LITERAL">LEFT</TT>连接<TT CLASS="LITERAL">LATERAL</TT>条目，
其他为<TT CLASS="LITERAL">LATERAL</TT>条目计算每个行集的行集将不会是明确定义的行集。
因此，尽管一个构造（如<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>X</I></TT> RIGHT JOIN LATERAL <TT CLASS="REPLACEABLE"><I>Y</I></TT></TT>）
在语法结构上合法，并不实际上允许<TT CLASS="REPLACEABLE"><I>Y</I></TT>引用<TT CLASS="REPLACEABLE"><I>X</I></TT>。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-WHERE"></A><H3><TT CLASS="LITERAL">WHERE</TT> 子句</H3><P>可选的<TT CLASS="LITERAL">WHERE</TT>条件有如下常见的形式：
</P><PRE CLASS="SYNOPSIS">WHERE <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
></PRE><P>
这里<TT CLASS="REPLACEABLE"><I>condition</I></TT>可以是任意生成类型为
<TT CLASS="TYPE">boolean</TT>的表达式。任何不满足这个条件的行都会从输出中删除。
如果一个行的数值代入到条件中计算出来的结果为真，那么该行就算满足条件。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-GROUPBY"></A><H3><TT CLASS="LITERAL">GROUP BY</TT> 子句</H3><P>可选的<TT CLASS="LITERAL">GROUP BY</TT>子句的一般形式
</P><PRE CLASS="SYNOPSIS">GROUP BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...]</PRE><P></P><P>它将把所有在组合表达式上拥有相同值的行压缩成一行。
<TT CLASS="REPLACEABLE"><I>expression</I></TT>可以是一个输入字段名字，
或者是一个输出字段(<TT CLASS="COMMAND">SELECT</TT>列表项)的名字或序号，
或者也可以是任意输入字段组成的表达式。在有歧义的情况下，
一个<TT CLASS="LITERAL">GROUP BY</TT>的名字将被解释成输入字段的名字，而不是输出字段的名字。</P><P>如果使用了聚集函数，那么就会对每组中的所有行进行计算并生成一个单独的值
(而如果没有<TT CLASS="LITERAL">GROUP BY</TT>，那么聚集将对选出来的所有行计算出一个单独的值)。
如果出现了<TT CLASS="LITERAL">GROUP BY</TT>，那么<TT CLASS="COMMAND">SELECT</TT>
列表表达式中再引用那些没有分组的字段就是非法的，除非放在聚集函数里，
或未分组的字段函数上依赖于分组的字段，因为对于未分组的字段，可能会返回多个数值。
如果分组的字段（或它们的一个子集）是包含未分组字段的表的主键，那么存在一个函数依赖。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-HAVING"></A><H3><TT CLASS="LITERAL">HAVING</TT> 子句</H3><P>可选的<TT CLASS="LITERAL">HAVING</TT>子句有如下形式：
</P><PRE CLASS="SYNOPSIS">HAVING <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
></PRE><P>
这里<TT CLASS="REPLACEABLE"><I>condition</I></TT>与为
<TT CLASS="LITERAL">WHERE</TT>子句里声明的相同。</P><P><TT CLASS="LITERAL">HAVING</TT>去除了一些不满足条件的组行。它与<TT CLASS="LITERAL">WHERE</TT>
不同：<TT CLASS="LITERAL">WHERE</TT>在使用<TT CLASS="LITERAL">GROUP BY</TT>之前过滤出单独的行，
而<TT CLASS="LITERAL">HAVING</TT>过滤由<TT CLASS="LITERAL">GROUP BY</TT>创建的行。
在<TT CLASS="REPLACEABLE"><I>condition</I></TT>
里引用的每个字段都必须无歧义地引用一个分组的行，除非引用出现在一个聚集函数里。</P><P><TT CLASS="LITERAL">HAVING</TT>的出现把查询变成一个分组的查询，即使没有<TT CLASS="LITERAL">GROUP BY</TT>
子句也这样。这一点和那些包含聚集函数但没有<TT CLASS="LITERAL">GROUP BY</TT>子句的查询里发生的事情是一样的。
所有选取的行都被认为会形成一个单一的组，而<TT CLASS="COMMAND">SELECT</TT>
列表和<TT CLASS="LITERAL">HAVING</TT>子句只能从聚集函数里面引用表的字段。
这样的查询在<TT CLASS="LITERAL">HAVING</TT>条件为真的时候将发出一个行，如果为非真，则返回零行。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-WINDOW"></A><H3><TT CLASS="LITERAL">WINDOW</TT> 子句</H3><P><TT CLASS="LITERAL">WINDOW</TT>子句的一般形式是
</P><PRE CLASS="SYNOPSIS">WINDOW <TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
> AS ( <TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
> ) [, ...]</PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>window_name</I></TT>是可以在<TT CLASS="LITERAL">OVER</TT>
子句中引用的名字或随后的窗口定义，这里的<TT CLASS="REPLACEABLE"><I>window_definition</I></TT>是
</P><PRE CLASS="SYNOPSIS">[ <TT
CLASS="REPLACEABLE"
><I
>existing_window_name</I
></TT
> ]
[ PARTITION BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ]
[ ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <TT
CLASS="REPLACEABLE"
><I
>frame_clause</I
></TT
> ]</PRE><P></P><P>如果声明了<TT CLASS="REPLACEABLE"><I>existing_window_name</I></TT>，
那么必须引用一个在<TT CLASS="LITERAL">WINDOW</TT>列表中出现的更早的项；新的窗口从这个项中拷贝分区子句，
和排序子句（如果有）。在这种情况下，这个新的窗口不能声明他自己的<TT CLASS="LITERAL">PARTITION BY</TT>子句，
但是如果拷贝的窗口没有排序子句的话他可以声明<TT CLASS="LITERAL">ORDER BY</TT>子句。
新窗口总是使用他自己的框架子句；拷贝的窗口必须不能声明框架子句。</P><P><TT CLASS="LITERAL">PARTITION BY</TT>列表的元素的以与<A HREF="sql-select.html#SQL-GROUPBY"><I><I>GROUP BY</I> 子句</I></A>
的元素相同的方式来解释，除了他们总是简单的表达式并且从不是一个输出列的名称或者编号。
另外一个差异是这些表达式可以包含聚集函数调用，而在常规的<TT CLASS="LITERAL">GROUP BY</TT>子句中这是不允许的。
在这里允许是因为开窗在分组和聚集之后发生。</P><P>同样的，<TT CLASS="LITERAL">ORDER BY</TT>列表的元素以与<A HREF="sql-select.html#SQL-ORDERBY"><I><I>ORDER BY</I> 子句</I></A>
的元素相同的方式来解释，除了这个表达式总是作为简单的表达式并且从不是一个输出列的名称或者编号。</P><P>可选的<TT CLASS="REPLACEABLE"><I>frame_clause</I></TT>为依赖于框架的窗口函数（不是所有）定义
<I CLASS="FIRSTTERM">窗口框架</I>。窗口框架是查询中的每行（称为<I CLASS="FIRSTTERM">当前行</I>）的一组相关行。
<TT CLASS="REPLACEABLE"><I>frame_clause</I></TT>可以是下列之一
</P><PRE CLASS="SYNOPSIS">[ RANGE | ROWS ] <TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
>
[ RANGE | ROWS ] BETWEEN <TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
> AND <TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>和<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>可以是下列之一
</P><PRE CLASS="SYNOPSIS">UNBOUNDED PRECEDING
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> PRECEDING
CURRENT ROW
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> FOLLOWING
UNBOUNDED FOLLOWING</PRE><P>
如果省略了<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>，那么它的缺省是<TT CLASS="LITERAL">CURRENT ROW</TT>。
限制是<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>不能是<TT CLASS="LITERAL">UNBOUNDED FOLLOWING</TT>，
<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>不能是<TT CLASS="LITERAL">UNBOUNDED PRECEDING</TT>，
<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>选项在上面的列表中不能比<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>
选项出现的早，例如<TT CLASS="LITERAL">RANGE BETWEEN CURRENT ROW AND <TT CLASS="REPLACEABLE"><I>value</I></TT>
PRECEDING</TT>是不允许的。
</P><P>缺省框架选项是<TT CLASS="LITERAL">RANGE UNBOUNDED PRECEDING</TT>，这与<TT CLASS="LITERAL">RANGE BETWEEN UNBOUNDED PRECEDING AND
CURRENT ROW</TT>相同；它将框架设置为分区中的所有行，在<TT CLASS="LITERAL">ORDER BY</TT>
序列中是从当前行的最后一个元素开始（这意味着若无<TT CLASS="LITERAL">ORDER BY</TT>则是所有行）。
通常，<TT CLASS="LITERAL">UNBOUNDED PRECEDING</TT>表示框架从分区的第一行开始，类似的
<TT CLASS="LITERAL">UNBOUNDED FOLLOWING</TT>表示框架以分区的最后一行结束（不管是<TT CLASS="LITERAL">RANGE</TT>
还是<TT CLASS="LITERAL">ROWS</TT>模式）。在<TT CLASS="LITERAL">ROWS</TT>模式，<TT CLASS="LITERAL">CURRENT ROW</TT>
意味着框架以当前行开始或结束；但是在<TT CLASS="LITERAL">RANGE</TT>模式，意味着框架以当前行在
<TT CLASS="LITERAL">ORDER BY</TT>序列中的第一个或最后一个元素开始或结束。<TT CLASS="REPLACEABLE"><I>value</I></TT> <TT CLASS="LITERAL">PRECEDING</TT>
和<TT CLASS="REPLACEABLE"><I>value</I></TT> <TT CLASS="LITERAL">FOLLOWING</TT>子句目前只允许在<TT CLASS="LITERAL">ROWS</TT>模式。
他们表明框架以当前行之前或者之后许多行开始或者结束。<TT CLASS="REPLACEABLE"><I>value</I></TT>
必须是一个不包含任何变量、聚集函数或者窗口函数的整型表达式。该值不能为空或者负值；
但可以为0，并且这时选择当前行本身。</P><P>注意如果<TT CLASS="LITERAL">ORDER BY</TT>排序不能唯一地排列行，那么<TT CLASS="LITERAL">ROWS</TT>
选项可能产生不可预测的结果。<TT CLASS="LITERAL">RANGE</TT>选项是为了确保<TT CLASS="LITERAL">ORDER BY</TT>
序列中的对等的行能得到同等对待；任何两个对等行将会都在或者都不在框架中。</P><P>一个<TT CLASS="LITERAL">WINDOW</TT>语句的目的是指定出现在查询的<A HREF="sql-select.html#SQL-SELECT-LIST"><I><I>SELECT</I> 列表</I></A>
或者<A HREF="sql-select.html#SQL-ORDERBY"><I><I>ORDER BY</I> 子句</I></A>中的<I CLASS="FIRSTTERM">window 函数</I>的行为。
这些函数可以在其<TT CLASS="LITERAL">OVER</TT>子句中通过名称引用<TT CLASS="LITERAL">WINDOW</TT>子句条目。
一个<TT CLASS="LITERAL">WINDOW</TT>子句条目不需要在任何地方都引用；若它不在查询中使用，它将被忽略。
可以使用窗口程序而根本不需要任何<TT CLASS="LITERAL">WINDOW</TT>子句，
因为一个窗口函数调用可以直接在其<TT CLASS="LITERAL">OVER</TT>子句中指定其窗口定义。然而，
<TT CLASS="LITERAL">WINDOW</TT>子句会在多个窗口函数需要相同窗口定义时保存输入。</P><P>窗口函数在<A HREF="tutorial-window.html">第 3.5 &#33410;</A>, <A HREF="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">第 4.2.8 &#33410;</A>, 和
<A HREF="queries-table-expressions.html#QUERIES-WINDOW">第 7.2.4 &#33410;</A>中有详细描述。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-SELECT-LIST"></A><H3><TT CLASS="COMMAND">SELECT</TT> 列表</H3><P><TT CLASS="COMMAND">SELECT</TT>列表(在<TT CLASS="LITERAL">SELECT</TT>和<TT CLASS="LITERAL">FROM</TT>关键字之间的部分)
声明组成<TT CLASS="COMMAND">SELECT</TT>语句的输出行的表达式。这些表达式可以
(并且通常也会)引用在<TT CLASS="LITERAL">FROM</TT>子句里面计算出来的字段。</P><P>就像在一个表中，一个<TT CLASS="COMMAND">SELECT</TT>的每个输出列都有一个名称。
在一个简单的<TT CLASS="COMMAND">SELECT</TT>中，该名称仅用于标记显示的列，
但当<TT CLASS="COMMAND">SELECT</TT>是一个较大查询的子查询时，名称被较大查询视为子查询产生的虚表的字段名。
为了指定用于输出列的名称，要在列表达式后写<TT CLASS="LITERAL">AS</TT>
<TT CLASS="REPLACEABLE"><I>output_name</I></TT>。（您可以省略<TT CLASS="LITERAL">AS</TT>，
但只有当所需的输出名称不匹配任何<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>关键字时
(请参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-keywords-appendix.html">&#38468;&#24405; C</A>)。为了防止将来可能的关键字添加，
建议您要么写<TT CLASS="LITERAL">AS</TT>要么用双引号引起输出名称。）如果你不指定一个字段名，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>会自动选择一个名称。如果字段的表达式是一个简单的列引用，
那么选择的名称与字段名相同；在更复杂的情况下，可能会使用一个函数或类型名，
或系统会依赖于一个类似<TT CLASS="LITERAL">?column?</TT>的生成名。</P><P>一个输出列的名称可以用来参考<TT CLASS="LITERAL">ORDER BY</TT>和<TT CLASS="LITERAL">GROUP BY</TT>子句中的字段的值，
而不是在<TT CLASS="LITERAL">WHERE</TT>或者<TT CLASS="LITERAL">HAVING</TT>子句中的；反而您必须在那里写出表达式。</P><P>除了表达式，也可以在输出列表中使用<TT CLASS="LITERAL">*</TT>表示所有字段。
还可以用<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>table_name</I></TT>.*</TT>
作为来自该表的所有字段的缩写。这些情况下用<TT CLASS="LITERAL">AS</TT>指定新名称是不可能的；
输出列的名称将会与表列的名称相同。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-DISTINCT"></A><H3><TT CLASS="LITERAL">DISTINCT</TT> 子句</H3><P>如果声明了<TT CLASS="LITERAL">SELECT DISTINCT</TT>，那么就从结果集中删除所有重复的行
(每个有重复的组都保留一行)。<TT CLASS="LITERAL">SELECT ALL</TT>声明相反的作用：所有行都被保留(这是缺省)。</P><P><TT CLASS="LITERAL">SELECT DISTINCT ON ( <TT CLASS="REPLACEABLE"><I>expression</I></TT> [, ...] )</TT>
只保留那些在给出的表达式上运算出相同结果的行集合中的第一行。<TT CLASS="LITERAL">DISTINCT ON</TT>
表达式是使用与<TT CLASS="LITERAL">ORDER BY</TT>相同的规则进行解释的（见上文）。请注意，
除非使用了<TT CLASS="LITERAL">ORDER BY</TT>来保证需要的行首先出现，否则，<SPAN CLASS="QUOTE">"第一行"</SPAN>
是不可预测的。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;</PRE><P>
为每个地点检索最近的天气报告。但是如果没有使用<TT CLASS="LITERAL">ORDER BY</TT>
来强制对每个地点的时间值进行降序排序，那么就会得到每个地点的不知道什么时候的报告。</P><P><TT CLASS="LITERAL">DISTINCT ON</TT>表达式必须匹配最左边的<TT CLASS="LITERAL">ORDER BY</TT>表达式。
<TT CLASS="LITERAL">ORDER BY</TT>子句将通常包含额外的表达式来判断每个<TT CLASS="LITERAL">DISTINCT ON</TT>
组里面需要的行的优先级。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-UNION"></A><H3><TT CLASS="LITERAL">UNION</TT> 子句</H3><P><TT CLASS="LITERAL">UNION</TT>子句的一般形式是：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
> UNION [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>select_statement</I></TT>是任意没有
<TT CLASS="LITERAL">ORDER BY</TT>, <TT CLASS="LITERAL">LIMIT</TT>, <TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>,
<TT CLASS="LITERAL">FOR SHARE</TT>, 或 <TT CLASS="LITERAL">FOR KEY SHARE</TT>子句的<TT CLASS="COMMAND">SELECT</TT>语句。
如果用圆括弧包围，<TT CLASS="LITERAL">ORDER BY</TT>和<TT CLASS="LITERAL">LIMIT</TT>可以附着在子表达式里。
如果没有圆括弧，这些子句将交给<TT CLASS="LITERAL">UNION</TT>的结果使用，而不是给它们右边的输入表达式。</P><P><TT CLASS="LITERAL">UNION</TT>操作符计算那些涉及到的所有<TT CLASS="COMMAND">SELECT</TT>
语句返回的行的结果联合。一个行如果至少在两个结果集中的一个里面出现，
那么它就会在这两个结果集的集合联合中。两个作为<TT CLASS="LITERAL">UNION</TT>
直接操作数的<TT CLASS="COMMAND">SELECT</TT>必须生成相同数目的字段，
并且对应的字段必须有兼容的数据类型。</P><P>缺省的<TT CLASS="LITERAL">UNION</TT>结果不包含任何重复的行，除非声明了<TT CLASS="LITERAL">ALL</TT>选项。
<TT CLASS="LITERAL">ALL</TT>制止了消除重复的动作。因此，<TT CLASS="LITERAL">UNION ALL</TT>通常比
<TT CLASS="LITERAL">UNION</TT>明显要快，可能的情况下尽量使用<TT CLASS="LITERAL">ALL</TT>。
<TT CLASS="LITERAL">DISTINCT</TT>可以明确的指定消除重复行的缺省行为。</P><P>同一个<TT CLASS="COMMAND">SELECT</TT>语句中的多个<TT CLASS="LITERAL">UNION</TT>操作符是从左向右计算的，
除非用圆括弧进行了标识。</P><P>目前，<TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT> 和
<TT CLASS="LITERAL">FOR KEY SHARE</TT>不能在<TT CLASS="LITERAL">UNION</TT>的结果或输入中声明。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-INTERSECT"></A><H3><TT CLASS="LITERAL">INTERSECT</TT> 子句</H3><P><TT CLASS="LITERAL">INTERSECT</TT>子句的一般形式是：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
> INTERSECT [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
></PRE><P>
<TT CLASS="REPLACEABLE"><I>select_statement</I></TT>是任何不带
<TT CLASS="LITERAL">ORDER BY</TT>, <TT CLASS="LITERAL">LIMIT</TT>, <TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>,
<TT CLASS="LITERAL">FOR SHARE</TT>, 或 <TT CLASS="LITERAL">FOR KEY SHARE</TT>子句的<TT CLASS="COMMAND">SELECT</TT>语句。</P><P><TT CLASS="LITERAL">INTERSECT</TT>计算涉及的<TT CLASS="COMMAND">SELECT</TT>语句返回的行集合的交集。
如果一个行在两个结果集中都出现，那么它就在两个结果集的交集中。</P><P><TT CLASS="LITERAL">INTERSECT</TT>的结果不包含任何重复行，除非你声明了<TT CLASS="LITERAL">ALL</TT>选项。
用了<TT CLASS="LITERAL">ALL</TT>以后，一个在左边的表里有<TT CLASS="REPLACEABLE"><I>m</I></TT>个重复而在右边表里有
<TT CLASS="REPLACEABLE"><I>n</I></TT>个重复的行将在结果集中出现min(<TT CLASS="REPLACEABLE"><I>m</I></TT>,<TT CLASS="REPLACEABLE"><I>n</I></TT>)次。
<TT CLASS="LITERAL">DISTINCT</TT>可以明确的指定消除重复行的缺省行为。</P><P>除非用圆括号指明顺序，同一个<TT CLASS="COMMAND">SELECT</TT>语句中的多个
<TT CLASS="LITERAL">INTERSECT</TT>操作符是从左向右计算的。<TT CLASS="LITERAL">INTERSECT</TT>
比<TT CLASS="LITERAL">UNION</TT>绑定得更紧，也就是说<TT CLASS="LITERAL">A UNION B INTERSECT C</TT>
将理解成 <TT CLASS="LITERAL">A UNION (B INTERSECT C)</TT>。</P><P>目前，不能给<TT CLASS="LITERAL">INTERSECT</TT>的结果或者任何<TT CLASS="LITERAL">INTERSECT</TT>的输入声明
<TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT> 和
<TT CLASS="LITERAL">FOR KEY SHARE</TT>。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-EXCEPT"></A><H3><TT CLASS="LITERAL">EXCEPT</TT> 子句</H3><P><TT CLASS="LITERAL">EXCEPT</TT>子句有如下的通用形式：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
> EXCEPT [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
></PRE><P>
<TT CLASS="REPLACEABLE"><I>select_statement</I></TT>是任何没有
<TT CLASS="LITERAL">ORDER BY</TT>, <TT CLASS="LITERAL">LIMIT</TT>, <TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>,
<TT CLASS="LITERAL">FOR SHARE</TT>, 或 <TT CLASS="LITERAL">FOR KEY SHARE</TT>子句的<TT CLASS="COMMAND">SELECT</TT>表达式。</P><P><TT CLASS="LITERAL">EXCEPT</TT>操作符计算存在于左边<TT CLASS="COMMAND">SELECT</TT>
语句的输出而不存在于右边<TT CLASS="COMMAND">SELECT</TT>语句输出的行。</P><P><TT CLASS="LITERAL">EXCEPT</TT>的结果不包含任何重复的行，除非声明了<TT CLASS="LITERAL">ALL</TT>选项。
使用<TT CLASS="LITERAL">ALL</TT>时，一个在左边表中有<TT CLASS="REPLACEABLE"><I>m</I></TT>个重复而在右边表中有
<TT CLASS="REPLACEABLE"><I>n</I></TT>个重复的行将在结果中出现max(<TT CLASS="REPLACEABLE"><I>m</I></TT>-<TT CLASS="REPLACEABLE"><I>n</I></TT>,0)次。
<TT CLASS="LITERAL">DISTINCT</TT>可以明确的指定消除重复行的缺省行为。</P><P>除非用圆括弧指明顺序，否则同一个<TT CLASS="COMMAND">SELECT</TT>语句中的多个
<TT CLASS="LITERAL">EXCEPT</TT>操作符是从左向右计算的。<TT CLASS="LITERAL">EXCEPT</TT>
和<TT CLASS="LITERAL">UNION</TT>的绑定级别相同。</P><P>目前，不能给<TT CLASS="LITERAL">EXCEPT</TT>的结果或者任何<TT CLASS="LITERAL">EXCEPT</TT>的输入声明
<TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT> 和
<TT CLASS="LITERAL">FOR KEY SHARE</TT>子句。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-ORDERBY"></A><H3><TT CLASS="LITERAL">ORDER BY</TT> 子句</H3><P>可选的<TT CLASS="LITERAL">ORDER BY</TT>子句有下面的一般形式：
</P><PRE CLASS="SYNOPSIS">ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...]</PRE><P>
<TT CLASS="LITERAL">ORDER BY</TT>子句导致结果行根据指定的表达式进行排序。
如果根据最左边的表达式，两行的结果相同，那么就根据下一个表达式进行比较，
依此类推。如果对于所有声明的表达式他们都相同，那么按随机顺序返回。</P><P>每个<TT CLASS="REPLACEABLE"><I>expression</I></TT>可以是一个输出字段
(<TT CLASS="COMMAND">SELECT</TT>列表项)的名字或者序号，或者也可以是用输入字段的数值组成的任意表达式。</P><P>序数指的是输出字段按顺序(从左到右)的位置。这个特性可以对没有唯一名称的字段进行排序。
这不是必须的，因为总是可以通过<TT CLASS="LITERAL">AS</TT>子句给一个要输出的字段赋予一个名称。</P><P>在<TT CLASS="LITERAL">ORDER BY</TT>里还可以使用任意表达式，包括那些没有出现在
<TT CLASS="COMMAND">SELECT</TT>输出列表里面的字段。因此下面的语句现在是合法的：
</P><PRE CLASS="PROGRAMLISTING">SELECT name FROM distributors ORDER BY code;</PRE><P>
这个特性的一个局限就是应用于<TT CLASS="LITERAL">UNION</TT>,<TT CLASS="LITERAL">INTERSECT</TT>,<TT CLASS="LITERAL">EXCEPT</TT>
子句的结果的<TT CLASS="LITERAL">ORDER BY</TT>子句只能在一个输出字段名或者数字上声明，
而不能在一个表达式上声明。</P><P>如果一个<TT CLASS="LITERAL">ORDER BY</TT>表达式是一个简单名称，同时匹配结果字段和输入字段，
<TT CLASS="LITERAL">ORDER BY</TT>将把它解释成结果字段名称。这和<TT CLASS="LITERAL">GROUP BY</TT>
在同样情况下做的选择正相反。这样的不一致是用来和 SQL 标准兼容的。</P><P>可以给<TT CLASS="LITERAL">ORDER BY</TT>子句里每个字段加一个可选的<TT CLASS="LITERAL">ASC</TT>(升序，缺省)
或<TT CLASS="LITERAL">DESC</TT>(降序)关键字。还可以在<TT CLASS="LITERAL">USING</TT>
子句里声明一个排序操作符来实现排序。排序操作符必须小于或大于某些B-tree操作符族的成员。
<TT CLASS="LITERAL">ASC</TT>等效于使用<TT CLASS="LITERAL">USING &lt;</TT>而<TT CLASS="LITERAL">DESC</TT>等效于使用<TT CLASS="LITERAL">USING &gt;</TT>。
但是一个用户定义类型的创建者可以明确定义缺省的排序顺序，并且可以使用其他名称的操作符。</P><P>如果指定<TT CLASS="LITERAL">NULLS LAST</TT>，空值会在所有非空值之后排序；如果指定
<TT CLASS="LITERAL">NULLS FIRST</TT>，空值会在所有非空值之前排序。如果两者均未指定，
当指定<TT CLASS="LITERAL">ASC</TT>或缺省时，默认反应时是<TT CLASS="LITERAL">NULLS LAST</TT>，
并且当指定<TT CLASS="LITERAL">DESC</TT>时，默认反应时是<TT CLASS="LITERAL">NULLS FIRST</TT>（因此，
默认地认为空是大于非空的）。当指定<TT CLASS="LITERAL">USING</TT>时，
默认空排序依赖于操作符是小于还是大于操作符。</P><P>请注意排序选项仅适用于他们遵循的表达式；例如<TT CLASS="LITERAL">ORDER BY x, y DESC</TT>
不意味着与<TT CLASS="LITERAL">ORDER BY x DESC, y DESC</TT>相同。</P><P>字符类型的数据是按照应用于被排序的字段的排序规则排序的。可以在需要时通过在
<TT CLASS="REPLACEABLE"><I>expression</I></TT>中包含<TT CLASS="LITERAL">COLLATE</TT>
子句覆盖，例如<TT CLASS="LITERAL">ORDER BY mycolumn COLLATE "en_US"</TT>。更多信息请参阅
<A HREF="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS">第 4.2.10 &#33410;</A>和<A HREF="collation.html">第 22.2 &#33410;</A>。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-LIMIT"></A><H3><TT CLASS="LITERAL">LIMIT</TT> 子句</H3><P><TT CLASS="LITERAL">LIMIT</TT>子句由两个独立的子句组成：
</P><PRE CLASS="SYNOPSIS">LIMIT { <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> | ALL }
OFFSET <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
></PRE><P>
<TT CLASS="REPLACEABLE"><I>count</I></TT>声明返回的最大行数，
而<TT CLASS="REPLACEABLE"><I>start</I></TT>声明开始返回行之前忽略的行数。
如果两个都指定了，那么在开始计算<TT CLASS="REPLACEABLE"><I>count</I></TT>
个返回行之前将先跳过<TT CLASS="REPLACEABLE"><I>start</I></TT>行。</P><P>如果<TT CLASS="REPLACEABLE"><I>count</I></TT>表达式评估为NULL，
它被当做<TT CLASS="LITERAL">LIMIT ALL</TT>，也就是，没有限制。如果
<TT CLASS="REPLACEABLE"><I>start</I></TT>评估为NULL，他与
<TT CLASS="LITERAL">OFFSET 0</TT>相同对待。</P><P>SQL:2008引入了一个不同的语法来达到相同的效果，这也是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>支持的。这是：
</P><PRE CLASS="SYNOPSIS">OFFSET <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> ] { ROW | ROWS } ONLY</PRE><P>
在该语法中，为<TT CLASS="REPLACEABLE"><I>start</I></TT>或<TT CLASS="REPLACEABLE"><I>count</I></TT>
提供除简单整型常量之外的东西时，你必须写圆括号。如果<TT CLASS="REPLACEABLE"><I>count</I></TT>
在<TT CLASS="LITERAL">FETCH</TT>子句中省略了，它默认为1。<TT CLASS="LITERAL">ROW</TT>和<TT CLASS="LITERAL">ROWS</TT>
以及<TT CLASS="LITERAL">FIRST</TT>和<TT CLASS="LITERAL">NEXT</TT>是不影响这些子句的效果的干扰词。
根据该标准，若两个都存在则<TT CLASS="LITERAL">OFFSET</TT>子句必须在<TT CLASS="LITERAL">FETCH</TT>子句之前出现；
但是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的要求更为宽松并且允许任意一种顺序。</P><P>使用<TT CLASS="LITERAL">LIMIT</TT>的一个好习惯是使用一个<TT CLASS="LITERAL">ORDER BY</TT>子句把结果行限制成一个唯一的顺序。
否则你会得到无法预料的结果子集，你可能想要第十行到第二十行，但是是以什么顺序的第十行到第二十行？
除非你声明<TT CLASS="LITERAL">ORDER BY</TT> ，否则你不知道什么顺序。</P><P>查询优化器在生成查询规划时会把<TT CLASS="LITERAL">LIMIT</TT>考虑进去，所以你很有可能因给出的
<TT CLASS="LITERAL">LIMIT</TT>和<TT CLASS="LITERAL">OFFSET</TT>值不同而得到不同的规划(生成不同的行序)。
因此用不同的<TT CLASS="LITERAL">LIMIT</TT>/<TT CLASS="LITERAL">OFFSET</TT>值选择不同的查询结果的子集
<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">将不会产生一致的结果</I></SPAN>，除非你用<TT CLASS="LITERAL">ORDER BY</TT>
强制生成一个可预计的结果顺序。这可不是 bug ；这是 SQL 生来的特点，
因为除非用了<TT CLASS="LITERAL">ORDER BY</TT>约束顺序，SQL 不保证查询生成的结果有任何特定的顺序。</P><P>如果没有一个<TT CLASS="LITERAL">ORDER BY</TT>来强制选择一个确定性子集，那么重复执行相同的
<TT CLASS="LITERAL">LIMIT</TT>查询返回不同的表行的子集甚至都是可能的。同样，
这不是一个漏洞；结果的确定在这种情况下没法保证。</P></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-FOR-UPDATE-SHARE"></A><H3>锁定子句</H3><P><TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT>
和 <TT CLASS="LITERAL">FOR KEY SHARE</TT> 是 <I CLASS="FIRSTTERM">锁定子句</I>;他们影响
<TT CLASS="LITERAL">SELECT</TT>如何从表中锁定行作为获得的行。</P><P>锁定子句的一般形式：
</P><PRE CLASS="SYNOPSIS">FOR <TT
CLASS="REPLACEABLE"
><I
>lock_strength</I
></TT
> [ OF <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [, ...] ] [ NOWAIT ]</PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>lock_strength</I></TT>可以是下列之一：
</P><PRE CLASS="SYNOPSIS">&#13;UPDATE
NO KEY UPDATE
SHARE
KEY SHARE</PRE><P></P><P><TT CLASS="LITERAL">FOR UPDATE</TT>令那些被<TT CLASS="COMMAND">SELECT</TT>检索出来的行被锁住，
就像要更新一样。这样就避免它们在当前事务结束前被其它事务修改或者删除；也就是说，
其它企图<TT CLASS="COMMAND">UPDATE</TT>, <TT CLASS="COMMAND">DELETE</TT>, <TT CLASS="COMMAND">SELECT FOR UPDATE</TT>,
<TT CLASS="COMMAND">SELECT FOR NO KEY UPDATE</TT>, <TT CLASS="COMMAND">SELECT FOR SHARE</TT> 或
<TT CLASS="COMMAND">SELECT FOR KEY SHARE</TT>这些行的事务将被阻塞，直到当前事务结束。
<TT CLASS="LITERAL">FOR UPDATE</TT>锁模式也可以通过在一个行上<TT CLASS="COMMAND">DELETE</TT>或在特定的字段上修改值的
<TT CLASS="COMMAND">UPDATE</TT>获得。目前，为<TT CLASS="COMMAND">UPDATE</TT>情况考虑的字段设置是那些有唯一索引并且可以用于外键的
（所以不考虑局部索引和表达式索引），但是这个可能会在将来改变。同样，
如果一个来自其它事务的<TT CLASS="COMMAND">UPDATE</TT>, <TT CLASS="COMMAND">DELETE</TT>,
<TT CLASS="COMMAND">SELECT FOR UPDATE</TT>已经锁住了某个或某些选定的行，<TT CLASS="COMMAND">SELECT FOR UPDATE</TT>
将等到那些事务结束，并且将随后锁住并返回更新的行(或者不返回行，如果行已经被删除)。
但是，在<TT CLASS="LITERAL">REPEATABLE READ</TT>或<TT CLASS="LITERAL">SERIALIZABLE</TT>事务内部，
如果在事务开始时要被锁定的行已经改变了，那么将抛出一个错误。更多的讨论参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/mvcc.html">第 13 &#31456;</A>。</P><P><TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>的行为类似，只是获得的锁比较弱：这个锁将不锁定
尝试在相同的行上获得锁的<TT CLASS="LITERAL">SELECT FOR KEY SHARE</TT>命令。
这个锁模式也可以通过任何不争取<TT CLASS="LITERAL">FOR UPDATE</TT>锁的<TT CLASS="COMMAND">UPDATE</TT>获得。</P><P><TT CLASS="LITERAL">FOR SHARE</TT>的行为类似，只是它在每个检索出来的行上要求一个共享锁，
而不是一个排它锁。一个共享锁阻塞其它事务在这些行上执行<TT CLASS="COMMAND">UPDATE</TT>,
<TT CLASS="COMMAND">DELETE</TT>, <TT CLASS="COMMAND">SELECT FOR UPDATE</TT> 或
<TT CLASS="COMMAND">SELECT FOR NO KEY UPDATE</TT>，却不阻止他们执行<TT CLASS="COMMAND">SELECT FOR SHARE</TT> 或
<TT CLASS="COMMAND">SELECT FOR KEY SHARE</TT>。</P><P><TT CLASS="LITERAL">FOR KEY SHARE</TT>的行为类似于<TT CLASS="LITERAL">FOR SHARE</TT>，只是锁比较弱：
阻塞<TT CLASS="LITERAL">SELECT FOR UPDATE</TT>但不阻塞<TT CLASS="LITERAL">SELECT FOR NO KEY UPDATE</TT>。
一个共享键块阻塞其他事务执行<TT CLASS="COMMAND">DELETE</TT>或任意改变键值的<TT CLASS="COMMAND">UPDATE</TT>，
但是不阻塞其他<TT CLASS="COMMAND">UPDATE</TT>，也不阻止<TT CLASS="COMMAND">SELECT FOR NO KEY UPDATE</TT>,
<TT CLASS="COMMAND">SELECT FOR SHARE</TT>, 或 <TT CLASS="COMMAND">SELECT FOR KEY SHARE</TT>。</P><P>为了避免操作等待其它事务提交，使用<TT CLASS="LITERAL">NOWAIT</TT>选项。如果被选择的行不能立即被锁住，
那么语句将会立即报告一个错误，而不是等待。请注意，<TT CLASS="LITERAL">NOWAIT</TT>只适用于行级别的锁，
要求的表级锁<TT CLASS="LITERAL">ROW SHARE</TT>仍然以通常的方法进行(参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/mvcc.html">第 13 &#31456;</A>)。
如果需要申请表级别的锁同时又不等待，那么你可以使用<A HREF="sql-lock.html">LOCK</A>的
<TT CLASS="LITERAL">NOWAIT</TT>选项。</P><P>如果在锁定子句中明确指定了表名字，那么将只有这些指定的表被锁定，其他在
<TT CLASS="COMMAND">SELECT</TT>中使用的表将不会被锁定。
一个其后不带表列表的锁定子句将锁定该声明中所有使用的表。
如果锁定子句应用于一个视图或者子查询，它同样将锁定所有该视图或子查询中使用到的表。
但是这些子句不适用于被主查询引用的<TT CLASS="LITERAL">WITH</TT>查询。
如果你想要行锁定发生在<TT CLASS="LITERAL">WITH</TT>查询中，那么在<TT CLASS="LITERAL">WITH</TT>查询中指定锁定子句。</P><P>多个锁定子句可以用于为不同的表指定不同的锁定模式。如果一个表出同时出现
(或隐含同时出现)在多个锁定子句中，那么将看做只被最强的那个声明了处理。
类似的，如果影响一个表的任意子句中出现了<TT CLASS="LITERAL">NOWAIT</TT>，
那么该表将按照<TT CLASS="LITERAL">NOWAIT</TT>处理。</P><P>锁定子句不能在那些无法使用独立的表行清晰标识返回行的环境里使用；比如，它不能和聚集一起使用。</P><P>当锁定子句出现在<TT CLASS="COMMAND">SELECT</TT>查询的顶层时，锁定的行恰好是被查询返回的行；
在连接查询的情况下，锁定的行是那些有助于返回连接的行。另外，
满足查询条件的行作为查询快照将被锁定，尽管如果在快照后他们被更新不再满足查询条件
就不再被返回。如果使用了<TT CLASS="LITERAL">LIMIT</TT>，那么一旦返回足够的行满足限制锁定将停止
（但是请注意，通过<TT CLASS="LITERAL">OFFSET</TT>跳过的行将被锁定）。相似的，如果锁定子句用于游标查询，
只有实际抓取到的行或通过游标跳过的行将被锁定。</P><P>当锁定子句出现在子<TT CLASS="COMMAND">SELECT</TT>中时，锁定的行是那些通过子查询返回到外查询的行。
这些包含的行可能比单独检查子查询时给出的行更少，因为外查询的条件可能会用来优化子查询的执行。
例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;</PRE><P>
将只锁定<TT CLASS="LITERAL">col1 = 5</TT>的行，即使那个条件不是子查询中的原文。</P><P>以前的版本未能保持锁，通过一个稍后的保存点来改善。例如，这段代码：
</P><PRE CLASS="PROGRAMLISTING">BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;</PRE><P>
<TT CLASS="LITERAL">FOR UPDATE</TT>锁将会在<TT CLASS="COMMAND">ROLLBACK TO</TT>之后无法保持。这在版本9.3中已经修复了。</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P>一个<TT CLASS="COMMAND">SELECT</TT>命令运行在<TT CLASS="LITERAL">READ COMMITTED</TT>事务隔离级别和使用
<TT CLASS="LITERAL">ORDER BY</TT>和一个锁定子句返回顺序混乱的行是可能的。这是因为<TT CLASS="LITERAL">ORDER BY</TT>
先生效。命令排序结果，但是可能会在其中一行或多行上获取锁的时候被阻塞。一旦<TT CLASS="LITERAL">SELECT</TT>
的阻塞被解除后，某些顺序字段值可能被修改，导致这些行混乱了（尽管他们还是原先字段值的顺序）。
可以在需要的时候通过在子查询中放置<TT CLASS="LITERAL">FOR UPDATE/SHARE</TT>子句来避开，例如
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;</PRE><P>
请注意这将导致锁定<TT CLASS="STRUCTNAME">mytable</TT>的所有行，而顶层的<TT CLASS="LITERAL">FOR UPDATE</TT>
将会实际上仅锁住返回行。这可能会产生一个显著的性能差异，尤其是如果<TT CLASS="LITERAL">ORDER BY</TT>
与<TT CLASS="LITERAL">LIMIT</TT>或者其他限制结合。仅当顺序列的并发更新是预期的并且需要一个严格的排序结果时，
该技术才是建议使用的。</P><P>在<TT CLASS="LITERAL">REPEATABLE READ</TT>或<TT CLASS="LITERAL">SERIALIZABLE</TT>事务隔离级别，
这可能会导致一个序列化失败（<TT CLASS="LITERAL">SQLSTATE</TT>为<TT CLASS="LITERAL">'40001'</TT>），
所以在这些隔离级别下接收次序混乱的行是不可能的。</P></TD></TR></TABLE></DIV></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-TABLE"></A><H3><TT CLASS="LITERAL">TABLE</TT> 命令</H3><P>命令：
</P><PRE CLASS="PROGRAMLISTING">TABLE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></PRE><P>
完全等价于：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></PRE><P>
它可以用作复杂查询中的一部分的一个顶级的命令或者一个节省空间的语法变体。</P></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN80537"></A><H2>例子</H2><P> 将表<TT CLASS="LITERAL">films</TT>和表<TT CLASS="LITERAL">distributors</TT>连接在一起：
</P><PRE CLASS="PROGRAMLISTING">SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...</PRE><P>
</P><P>统计用<TT CLASS="LITERAL">kind</TT>分组的每组电影的长度<TT CLASS="LITERAL">len</TT>总和：
</P><PRE CLASS="PROGRAMLISTING">SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38</PRE><P>
</P><P>统计用<TT CLASS="LITERAL">kind</TT>分组的每组电影的长度<TT CLASS="LITERAL">len</TT>总和不足五小时的组：
</P><PRE CLASS="PROGRAMLISTING">SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38</PRE><P>
</P><P> 下面两个例子是根据第二列(<TT CLASS="LITERAL">name</TT>)的内容对单独的结果排序的相同的方法：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward</PRE><P>
</P><P>下面这个例子演示如何获得表<TT CLASS="LITERAL">distributors</TT>和<TT CLASS="LITERAL">actors</TT>的连接，
只将每个表中以字母 W 开头的取出来。因为只取了不重复的行，所以关键字<TT CLASS="LITERAL">ALL</TT>被省略了：
</P><PRE CLASS="PROGRAMLISTING">distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen</PRE><P>
</P><P> 这个例子显示了如何在<TT CLASS="LITERAL">FROM</TT>子句中使用函数，包括带有和不带字段定义列表的。
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney</PRE><P>
</P><P> 这个例子显示了如何使用一个简单的<TT CLASS="LITERAL">WITH</TT>子句：
</P><PRE CLASS="PROGRAMLISTING">WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422</PRE><P>
请注意<TT CLASS="LITERAL">WITH</TT>查询只评估一次，所以我们获得两组相同的三个随机值。
</P><P> 这个例子使用<TT CLASS="LITERAL">WITH RECURSIVE</TT>
从一个只显示直接属下的表中找到所有职员Mary的属下（直接或间接），和他们的间接级别，
</P><PRE CLASS="PROGRAMLISTING">WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;</PRE><P>
请注意递归查询的典型形式：一个初始条件，紧接着是<TT CLASS="LITERAL">UNION</TT>，
然后是查询的递归部分。确定查询的递归部分最终将不会返回元组，否则查询将无限循环下去。
（请参阅<A HREF="queries-with.html">第 7.8 &#33410;</A>获取更多示例。）
</P><P>这个例子使用<TT CLASS="LITERAL">LATERAL</TT>为<TT CLASS="STRUCTNAME">manufacturers</TT>表的每行应用一个设置返回函数
<CODE CLASS="FUNCTION">get_product_names()</CODE>：
</P><PRE CLASS="PROGRAMLISTING">SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;</PRE><P>
当前没有任何产品的制造商将不会出现在结果中，因为这是一个内连接。
如果我们希望在结果中包括这种制造商的名字，我们可以这样做：
</P><PRE CLASS="PROGRAMLISTING">SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN80577"></A><H2>兼容性</H2><P><TT CLASS="COMMAND">SELECT</TT>语句和 SQL 标准兼容。但是还有一些扩展和一些缺少的特性。</P><DIV CLASS="REFSECT2"><A NAME="AEN80581"></A><H3>省略 <TT CLASS="LITERAL">FROM</TT> 子句</H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许在一个查询里省略<TT CLASS="LITERAL">FROM</TT>子句。
它的最直接用途就是计算简单的常量表达式的结果：
</P><PRE CLASS="PROGRAMLISTING">SELECT 2+2;

 ?column?
----------
        4</PRE><P>
其它有些<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>数据库不能这么做，除非引入一个单行的伪表做为
<TT CLASS="COMMAND">SELECT</TT>的数据源。
</P><P>请注意，如果没有声明<TT CLASS="LITERAL">FROM</TT>子句，那么查询不能引用任何数据库表。
比如，下面的查询是非法的：
</P><PRE CLASS="PROGRAMLISTING">SELECT distributors.* WHERE distributors.name = 'Westward';</PRE><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.1 之前的版本支持这种形式的查询，
为查询里引用的每个表都增加一个隐含的条目到<TT CLASS="LITERAL">FROM</TT>子句中。
现在这个不再是允许的了。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80595"></A><H3>省略 <TT CLASS="LITERAL">AS</TT> 关键字</H3><P>在SQL标准中，每当新列名称是一个有效的列名时（也就是，与任意保留关键字都不同），
可选的关键字<TT CLASS="LITERAL">AS</TT>可以在输出列名之前省略。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
限制略多一些：不管是保留还是不保留，如果新列名匹配任何关键字，<TT CLASS="LITERAL">AS</TT>是必要的。
建议的做法是使用<TT CLASS="LITERAL">AS</TT>或者双括号括起输出列名称，以阻止与将来补充的关键字有任何可能的冲突。</P><P>在<TT CLASS="LITERAL">FROM</TT>项中，标准和<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>都允许<TT CLASS="LITERAL">AS</TT>
在一个无限制关键字别名之前省略。但是这对输出列名是不切实际的，因为语法的歧义。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80607"></A><H3><TT CLASS="LITERAL">ONLY</TT>和继承</H3><P>SQL标准需要在写<TT CLASS="LITERAL">ONLY</TT>时括号括起表名，例如
<TT CLASS="LITERAL">SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...</TT>。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>认为括号是可选的。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许写一个尾随的<TT CLASS="LITERAL">*</TT>以明确指定包括子表的非
<TT CLASS="LITERAL">ONLY</TT>行为。标准不允许这样。</P><P>（该点同样适用于所有支持<TT CLASS="LITERAL">ONLY</TT>选项的SQL命令。）</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80620"></A><H3><TT CLASS="LITERAL">FROM</TT>中的函数调用</H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许把函数调用直接写作<TT CLASS="LITERAL">FROM</TT>列表的一个成员。
在SQL标准中应该有必要在子<TT CLASS="COMMAND">SELECT</TT>中包含这样一个函数；也就是，
该语法<TT CLASS="LITERAL">FROM <TT CLASS="REPLACEABLE"><I>func</I></TT>(...) <TT CLASS="REPLACEABLE"><I>alias</I></TT></TT>等价于
<TT CLASS="LITERAL">FROM LATERAL (SELECT <TT CLASS="REPLACEABLE"><I>func</I></TT>(...)) <TT CLASS="REPLACEABLE"><I>alias</I></TT></TT>。
请注意<TT CLASS="LITERAL">LATERAL</TT>被认为是隐含的；这是因为标准要求<TT CLASS="LITERAL">LATERAL</TT>语义为
一个在<TT CLASS="LITERAL">FROM</TT>中的<TT CLASS="LITERAL">UNNEST()</TT>条目。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
对待<TT CLASS="LITERAL">UNNEST()</TT>和其他设置返回函数相同。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80639"></A><H3><TT CLASS="LITERAL">GROUP BY</TT> 和 <TT CLASS="LITERAL">ORDER BY</TT>里可用的命名空间</H3><P>在 SQL-92 标准里，<TT CLASS="LITERAL">ORDER BY</TT>子句只能使用输出字段名或者编号，
而<TT CLASS="LITERAL">GROUP BY</TT>子句只能用基于输入字段名的表达式。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
对这两个子句都进行了扩展，允许另外一种选择(但是如果存在歧义，则使用标准的解释)。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>还允许两个子句声明任意的表达式。
请注意在表达式中出现的名字总是被当作输入字段名，而不是输出字段名。</P><P>SQL:1999 以及之后的一个略微不同的定义并不能和 SQL-92 完全向前兼容。不过，
在大多数情况下，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将把一个<TT CLASS="LITERAL">ORDER BY</TT>
或<TT CLASS="LITERAL">GROUP BY</TT>表达式解析成为 SQL:1999 制定的那样。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80652"></A><H3>函数依赖</H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>只在表的主键包含在<TT CLASS="LITERAL">GROUP BY</TT>
列表中时识别函数依赖（允许在<TT CLASS="LITERAL">GROUP BY</TT>中省略字段）。
SQL标准指定应该被识别的附加条件。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80658"></A><H3><TT CLASS="LITERAL">WINDOW</TT> 子句限制</H3><P>SQL标准为窗口<TT CLASS="REPLACEABLE"><I>frame_clause</I></TT>提供了附加选项。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>目前仅支持上面列出的选项。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80664"></A><H3><TT CLASS="LITERAL">LIMIT</TT> 和 <TT CLASS="LITERAL">OFFSET</TT></H3><P>子句<TT CLASS="LITERAL">LIMIT</TT>和<TT CLASS="LITERAL">OFFSET</TT>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
特定的语法，也是<SPAN CLASS="PRODUCTNAME">MySQL</SPAN>使用的。SQL:2008标准引入了
<TT CLASS="LITERAL">OFFSET ... FETCH {FIRST|NEXT} ...</TT>获取相同的功能，
如上面的<A HREF="sql-select.html#SQL-LIMIT"><I><I>LIMIT</I> 子句</I></A>子句所示。
该语法也被<SPAN CLASS="PRODUCTNAME">IBM DB2</SPAN>使用。（为<SPAN CLASS="PRODUCTNAME">Oracle</SPAN>
所写的应用程序通常使用一个涉及自动生成的<TT CLASS="LITERAL">rownum</TT>列的工作区，
来实现这些子句的效果，这在PostgreSQL中是不可用的。）</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80678"></A><H3><TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>, <TT CLASS="LITERAL">FOR UPDATE</TT>, <TT CLASS="LITERAL">FOR SHARE</TT>, <TT CLASS="LITERAL">FOR KEY SHARE</TT></H3><P>尽管<TT CLASS="LITERAL">FOR UPDATE</TT>出现在了SQL标准中，但是标准只允许它作为<TT CLASS="COMMAND">DECLARE CURSOR</TT>
的一个选项。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许它出现在任意<TT CLASS="COMMAND">SELECT</TT>
查询和子<TT CLASS="COMMAND">SELECT</TT>查询中，但是这是一个扩展。<TT CLASS="LITERAL">FOR NO KEY UPDATE</TT>,
<TT CLASS="LITERAL">FOR SHARE</TT>, <TT CLASS="LITERAL">FOR KEY SHARE</TT>变体和<TT CLASS="LITERAL">NOWAIT</TT>选项，
没有出现在标准中。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80694"></A><H3><TT CLASS="LITERAL">WITH</TT>中的数据修改语句</H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许<TT CLASS="COMMAND">INSERT</TT>, <TT CLASS="COMMAND">UPDATE</TT>, <TT CLASS="COMMAND">DELETE</TT>
用作<TT CLASS="LITERAL">WITH</TT>查询。这在SQL标准中是没有的。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN80703"></A><H3>非标准的子句</H3><P>子句<TT CLASS="LITERAL">DISTINCT ON</TT>在SQL标准中未定义。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-security-label.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-selectinto.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">SECURITY LABEL</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">SELECT INTO</TD></TR></TABLE></DIV></BODY></HTML>
