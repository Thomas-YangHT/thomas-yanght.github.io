<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>DELETE</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="DECLARE" HREF="sql-declare.html"><LINK REL="NEXT" TITLE="DISCARD" HREF="sql-discard.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/delete.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="DECLARE" HREF="sql-declare.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="DISCARD" HREF="sql-discard.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-DELETE"></A>DELETE</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN74886"></A><H2>&#21517;&#31216;</H2>DELETE&nbsp;--&nbsp;删除一个表中的行</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN74891"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">[ WITH [ RECURSIVE ] <TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
> [, ...] ]
DELETE FROM [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ * ] [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> ]
    [ USING <TT
CLASS="REPLACEABLE"
><I
>using_list</I
></TT
> ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> | WHERE CURRENT OF <TT
CLASS="REPLACEABLE"
><I
>cursor_name</I
></TT
> ]
    [ RETURNING * | <TT
CLASS="REPLACEABLE"
><I
>output_expression</I
></TT
> [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>output_name</I
></TT
> ] [, ...] ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN74901"></A><H2>描述</H2><P><TT CLASS="COMMAND">DELETE</TT>从指定的表里删除满足<TT CLASS="LITERAL">WHERE</TT>子句的行。
如果<TT CLASS="LITERAL">WHERE</TT>子句不存在，将删除表中所有行。结果是一个有效的空表。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B><A HREF="sql-truncate.html">TRUNCATE</A>是一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展，
它提供一个更快的从表中删除所有行的机制。</P></BLOCKQUOTE></DIV><P>使用数据库中其它表的信息删除某个表中的数据行有两个办法：使用子查询，
或者在<TT CLASS="LITERAL">USING</TT>子句中声明额外的表。哪种技巧更合适取决于特定的环境。</P><P>可选的<TT CLASS="LITERAL">RETURNING</TT>子句将使得<TT CLASS="COMMAND">DELETE</TT>计算并返回实际被删除了的行。
任何使用表字段的表达式和/或<TT CLASS="LITERAL">USING</TT>中提到的其他表的字段，
都可以用于计算。<TT CLASS="LITERAL">RETURNING</TT>列表的语法和<TT CLASS="COMMAND">SELECT</TT>输出列表的语法相同。</P><P>要对表进行删除，你必须对它有<TT CLASS="LITERAL">DELETE</TT>权限，同样也必须有<TT CLASS="LITERAL">USING</TT>
子句的表以及<TT CLASS="REPLACEABLE"><I>condition</I></TT>上读取的表的
<TT CLASS="LITERAL">SELECT</TT>权限。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN74924"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>with_query</I></TT></DT><DD><P><TT CLASS="LITERAL">WITH</TT>子句允许指定一个或多个可以通过<TT CLASS="COMMAND">DELETE</TT>查询中的名字引用的子查询。
参阅<A HREF="queries-with.html">第 7.8 &#33410;</A>和<A HREF="sql-select.html">SELECT</A>获取详细信息。</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>要删除行的表的名字（可以有模式修饰）。如果在表的名字前指定了<TT CLASS="LITERAL">ONLY</TT>，
则只从指定的表中删除匹配的行。如果没有指定<TT CLASS="LITERAL">ONLY</TT>，则从指定的表及其所有子表中的删除匹配的行。
可选的，可以在表名的后面指定<TT CLASS="LITERAL">*</TT>以明确的指出包括后代表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>alias</I></TT></DT><DD><P>目标表的别名。如果提供了别名，那么它将完全掩盖实际的表名。例如给定<TT CLASS="LITERAL">DELETE FROM foo AS f</TT>
之后，<TT CLASS="COMMAND">DELETE</TT>语句的剩余部分必须使用<TT CLASS="LITERAL">f</TT>而不是<TT CLASS="LITERAL">foo</TT>来引用该表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>using_list</I></TT></DT><DD><P>表表达式列表，允许来自其他表的列出现在<TT CLASS="LITERAL">WHERE</TT>条件中。这与可以在
<TT CLASS="COMMAND">SELECT</TT>命令的<A HREF="sql-select.html#SQL-FROM"><I><I>FROM</I> 子句</I></A>
中指定的表列表相似。例如，可以为该表的名字声明一个别名。不要在
<TT CLASS="REPLACEABLE"><I>using_list</I></TT>里重复目标表，除非你希望产生一个自连接。</P></DD><DT><TT CLASS="REPLACEABLE"><I>condition</I></TT></DT><DD><P>一个返回<TT CLASS="TYPE">boolean</TT>值的表达式，只用表达式返回<TT CLASS="LITERAL">true</TT>的行被删除。</P></DD><DT><TT CLASS="REPLACEABLE"><I>cursor_name</I></TT></DT><DD><P>在<TT CLASS="LITERAL">WHERE CURRENT OF</TT>条件中使用的游标的名字。要删除的行是最近从这个游标获取到的。
该游标必须是一个在<TT CLASS="COMMAND">DELETE</TT>的目标表中非分组的查询。请注意，<TT CLASS="LITERAL">WHERE CURRENT OF</TT>
不能和一个布尔条件一起指定，参阅<A HREF="sql-declare.html">DECLARE</A>获取更多关于和<TT CLASS="LITERAL">WHERE CURRENT OF</TT>
一起使用游标的信息。</P></DD><DT><TT CLASS="REPLACEABLE"><I>output_expression</I></TT></DT><DD><P>计算并在删除行后由<TT CLASS="COMMAND">DELETE</TT>命令返回的一个表达式。该表达式可以使用由
<TT CLASS="REPLACEABLE"><I>table_name</I></TT>命名的表的任意字段名或在<TT CLASS="LITERAL">USING</TT>
中列出的表。<TT CLASS="LITERAL">*</TT>返回所有字段。</P></DD><DT><TT CLASS="REPLACEABLE"><I>output_name</I></TT></DT><DD><P>用于返回的列名称。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN74993"></A><H2>输出</H2><P>成功时，<TT CLASS="COMMAND">DELETE</TT>命令返回形如
</P><PRE CLASS="SCREEN">DELETE <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
></PRE><P>
的标签。<TT CLASS="REPLACEABLE"><I>count</I></TT>是被删除的行数。
请注意，当删除被<TT CLASS="LITERAL">BEFORE DELETE</TT>触发器取消时，这个数字可能小于匹配
<TT CLASS="REPLACEABLE"><I>condition</I></TT>的行数。
如果<TT CLASS="REPLACEABLE"><I>count</I></TT>为 0 则没有行被该查询删除，
这个不认为是错误。</P><P>如果<TT CLASS="COMMAND">DELETE</TT>命令包含一个<TT CLASS="LITERAL">RETURNING</TT>子句，那么其结果非常类似于
<TT CLASS="COMMAND">SELECT</TT>语句基于<TT CLASS="LITERAL">RETURNING</TT>子句中包含的字段和值列表的结果，
只是基于被删除的行进行计算而已。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN75008"></A><H2>注意</H2><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许你在<TT CLASS="LITERAL">WHERE</TT>条件里引用其它表的字段，
方法是在<TT CLASS="LITERAL">USING</TT>子句里声明其它表。比如，要删除给出制片商制作的所有电影，可以：
</P><PRE CLASS="PROGRAMLISTING">DELETE FROM films USING producers
  WHERE producer_id = producers.id AND producers.name = 'foo';</PRE><P>
这里实际发生的事情是在<TT CLASS="STRUCTNAME">films</TT>和<TT CLASS="STRUCTNAME">producers</TT>之间的一个连接，
然后所有成功连接的<TT CLASS="STRUCTNAME">films</TT>行都标记为删除。这个语法不是标准的，更标准的语法是这么做：
</P><PRE CLASS="PROGRAMLISTING">DELETE FROM films
  WHERE producer_id IN (SELECT id FROM producers WHERE name = 'foo');</PRE><P>
有时候连接风格比子查询风格更容易写或者执行更快。
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN75019"></A><H2>例子</H2><P>删除所有电影(films)但不删除音乐(musicals)：
</P><PRE CLASS="PROGRAMLISTING">DELETE FROM films WHERE kind &lt;&gt; 'Musical';</PRE><P></P><P>清空<TT CLASS="LITERAL">films</TT>表：
</P><PRE CLASS="PROGRAMLISTING">DELETE FROM films;</PRE><P></P><P>从 tasks 表及其子表中删除，并返回所有被删除的行：
</P><PRE CLASS="PROGRAMLISTING">DELETE FROM tasks WHERE status = 'DONE' RETURNING *;</PRE><P></P><P>删除游标<TT CLASS="LITERAL">c_tasks</TT>当前指向的<TT CLASS="STRUCTNAME">tasks</TT>的行：
</P><PRE CLASS="PROGRAMLISTING">DELETE FROM tasks WHERE CURRENT OF c_tasks;</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN75032"></A><H2>兼容性</H2><P>这条命令遵循<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准，但是<TT CLASS="LITERAL">USING</TT>和<TT CLASS="LITERAL">RETURNING</TT>
子句是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的扩展，就像在<TT CLASS="COMMAND">DELETE</TT>中使用<TT CLASS="LITERAL">WITH</TT>。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-declare.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-discard.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">DECLARE</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">DISCARD</TD></TR></TABLE></DIV></BODY></HTML>
